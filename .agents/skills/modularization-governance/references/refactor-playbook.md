# 模块化最小重构手册

目标：针对脚本 `finding.code` 提供“低风险、可回滚”的最小动作。

## 1) `FILE_TOO_LARGE`

动作：
1. 拆分纯函数与副作用代码（先抽出纯逻辑）。
2. 把状态管理从 UI 文件中分离到 `hooks` / `state`。
3. 保留旧入口，逐步迁移调用。

完成标准：
1. 单文件主职责可一句话描述。
2. 业务规则不再散落在多个 UI 组件内。

## 2) `REVERSE_LAYER_IMPORT`

动作：
1. 建立 Facade 文件，统一跨模块访问入口。
2. 移除“深路径 import”，改为模块出口导入。
3. 对临时例外依赖加注释并记录到技术债清单。

完成标准：
1. 主要调用链只通过已声明入口。
2. 不再新增反向依赖。

## 3) `PUBLIC_API_TOO_WIDE`

动作：
1. 下线未使用导出。
2. 将内部类型改为模块私有，保留必要公共类型。
3. 对外 API 增加语义命名，避免泄露实现细节。

完成标准：
1. 对外接口数量下降且可解释。
2. 外部模块不再依赖内部实现常量/类型。

## 4) `HIGH_FAN_OUT`

动作：
1. 把 I/O 与业务判断分离，优先测试纯逻辑。
2. 引入最小测试夹具，覆盖核心分支。
3. 回归历史缺陷路径，补一条可复现测试。

完成标准：
1. 核心路径可在不启动完整 UI 的情况下测试。
2. 历史缺陷至少有一条防回归测试。

## 5) `CIRCULAR_DEPENDENCY`

动作：
1. 抽离共享抽象到更低层（通常是 `model` 或 `api`）。
2. 将双向依赖改为单向事件/回调接口。
3. 每打断一个环路就重跑检查脚本，避免一次大改。

完成标准：
1. `CIRCULAR_DEPENDENCY` 不再出现。

## 6) `DEEP_RELATIVE_IMPORT`

动作：
1. 建立模块出口 `index.ts` 或 facade 文件。
2. 替换 `../../../` 深路径导入为模块出口导入。

完成标准：
1. 深层相对路径导入降到阈值内。

## 7) `ORPHAN_FILES`

动作：
1. 确认是否死代码；若是则删除。
2. 若是合法入口，补充到 policy `entryFiles`。

完成标准：
1. 孤立文件数量降到阈值内。

## 8) `UNKNOWN_LAYER_FILES`

动作：
1. 把文件迁移到已定义层目录。
2. 或在 `layerOrder` 中扩展合法层并说明语义。

完成标准：
1. 未归层文件数量降到阈值内。

## 9) `UNUSED_DECLARATION` / `UNUSED_IMPORT_DECLARATION` / `UNUSED_EXPORT`

动作：
1. `UNUSED_EXPORT`：优先移除 `export` 暴露，先不删除定义本体。
2. `UNUSED_DECLARATION` / `UNUSED_IMPORT_DECLARATION`：删除未使用变量、参数、局部函数或 import。
3. 仅当定义在模块内也无任何引用时，才删除该定义。
4. 若是预留参数，统一改为 `_name` 并注明保留原因。
5. 若符号应该被使用，接入真实调用路径，不保留“未来可能会用”的死代码。

完成标准：
1. unused 报告中的对应问题码清零或显著下降。
